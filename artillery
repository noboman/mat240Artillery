import math
import numpy as np 
import matplotlib.pyplot as plt

# Constant for grvity
gravity = 9.8  # m/s^2
tolerance = 0.000001

def f(angle, initialSpeed, x):
    """
    Projectile height function:
    Returns the height of the function at a given x.
    y(x) = x * tan(theta) - g * x^2 / (2 * v^2 * cos^2(theta))
    """
    tanAngle = np.tan(angle)
    cosAngle = np.cos(angle)
    return x * tanAngle - gravity * x**2 / (2.0 * initialSpeed**2 * cosAngle**2)


def heightError(angle, initialSpeed, targetX, targetY):
    """
    Compares how high a projectile is when it's at targetX, and compare it to targetY (where it should be)
    If it's 0, that means it passes right through targetY
    """
    y_at_targetX = f(angle, initialSpeed, targetX)

    # Positive = above target, negative = below target, 0 = perfect hit
    return y_at_targetX - targetY



def bisectionRoot(initialSpeed, targetX, targetY, leftAngle, rightAngle):
    """
    Given two angles where one is below the target and the other is above,
    zoom in between them to find an angle that actually hits the target.
    """
    leftError = heightError(leftAngle, initialSpeed, targetX, targetY)
    rightError = heightError(rightAngle, initialSpeed, targetX, targetY)

    # If they don't have opposite signs, they don't save a hit
    if leftError * rightError > 0:
        return None

    for _ in range(100):
        midAngle = 0.5 * (leftAngle + rightAngle)
        midError = heightError(midAngle, initialSpeed, targetX, targetY)

        
        # If we're close enough to 0, or the interval is tiny, call it good
        if abs(midError) < tolerance or (rightAngle - leftAngle) < tolerance:
            return midAngle

        # Decide which half still has a sign change (so still contains the root) and update with the new midAngle
        if leftError * midError < 0:
            rightAngle = midAngle
            rightError = midError
        else:
            leftAngle = midAngle
            leftError = midError

    # Fallback if we somehow hit the iteration limit (one final bisection after we hit the limit)
    return 0.5 * (leftAngle + rightAngle)


def findAnglesForTarget(initialSpeed, targetX, targetY):
    """
    Try every angle between 1 and 89 degrees (step of 0.25). Whenever the sign of the error flips 
    sign between two angles, use bisectionRoot to lock in the actual angle that hits the target.
    """
    angles = []

    minAngle = math.radians(1.0)
    maxAngle = math.radians(89.0)
    angleStep = math.radians(0.25)

    leftAngle = minAngle
    leftError = heightError(leftAngle, initialSpeed, targetX, targetY)

    angle = minAngle + angleStep
    while angle <= maxAngle:
        rightError = heightError(angle, initialSpeed, targetX, targetY)

        # if we are true on this, means hit somewhere in between
        if leftError * rightError < 0:
            rootAngle = bisectionRoot(initialSpeed, targetX, targetY, leftAngle, angle)
            if rootAngle is not None:
                # Avoid adding basically the same root twice
                if not angles or abs(rootAngle - angles[-1]) > tolerance:
                    angles.append(rootAngle)

        # Slide window forward
        leftAngle = angle
        leftError = rightError
        angle += angleStep

    return angles


def buildAngleTable(initialSpeed, xValues, yValues):
    """
    For one fixed initial speed, build a lookup table:
    table[(x, y)] = list of angles in degrees, or None if out of range.
    """
    table = {}

    for targetX in xValues:
        for targetY in yValues:
            # Find all angles (amount of either 0, 1, or 2) that hit this (x, y) for this speed
            roots = findAnglesForTarget(initialSpeed, targetX, targetY)

            if not roots:
                table[(targetX, targetY)] = None
            else:
                # Convert to degrees and sort so low angle comes first
                angleDegrees = sorted(math.degrees(a) for a in roots)
                table[(targetX, targetY)] = angleDegrees

    return table

# def printAngleTable(initialSpeed, xValues, yValues, table):
#     """
#     For each starting speed and distance x*, this shows
#     the height difference y* and the angle(s) to use in degrees,
#     or OUT if the target canâ€™t be hit with that speed.
#     """

#     print(f"\n==============================")
#     print(f" Initial speed = {initialSpeed} m/s")
#     print(f"==============================")
#     print("For each distance x* (m), the table below shows")
#     print("the height difference y* (m) and the firing angle(s) in degrees.")
#     print("If it says OUT, that target is not reachable with this speed.\n")

#     for x in xValues:
#         print(f"\n--- Distance x* = {x} m ---")
#         print(f"{'y* (m)':>8} | {'angle(s) (deg)':>18}")
#         print("-" * 29)

#         for y in yValues:
#             angles = table[(x, y)]

#             if angles is None:
#                 angleText = "OUT"
#             else:
#                 # One angle = single trajectory; two = low and high arc
#                 if len(angles) == 1:
#                     angleText = f"{angles[0]:.1f}"
#                 else:
#                     angleText = f"{angles[0]:.1f} / {angles[1]:.1f}"

#             print(f"{y:8} | {angleText:>18}")


def plotAngleSweep(initialSpeed, targetX, targetY):
    """
    Blue = lower angles (short/low shots)
    Red = angle that actually hits the target (from our solver)
    Orange = higher angles (high/long shots)
    """
    # Get the angle that hits the target
    rootAngles = findAnglesForTarget(initialSpeed, targetX, targetY)
    rootAngleRad = rootAngles[0]                 # radians
    rootAngleDeg = math.degrees(rootAngleRad)    # degrees

    # Angles around the root angle that we want to show on the graph (degrees)
    angleOffsetsDeg = [-10, -5, -1, 0, 1, 5, 10]

    # hard coded colors and angles rn
    offsetColors = {
        -10:"#1f77b4",
        -5: "#1f77b4",
        -1: "#1f77b4",
         0: "#ff0000",
         1: "#ff7f0e",
         5: "#ff7f0e",
        10: "#ff7f0e",
    }

    xValues = np.linspace(0, targetX * 1.1, 300)
    maxHeight = 0.0

    for offsetDeg in angleOffsetsDeg:
        currentAngleDeg = rootAngleDeg + offsetDeg
        currentAngleRad = math.radians(currentAngleDeg)

        yValues = f(currentAngleRad, initialSpeed, xValues)

        # get max for zoom
        thisMax = np.max(yValues)
        if thisMax > maxHeight:
            maxHeight = thisMax

        lineColor = offsetColors[offsetDeg]

        plt.plot(xValues, yValues, color=lineColor)

    # Zoom to fit
    plt.xlim(0, targetX * 1.1)
    if maxHeight > 0:
        plt.ylim(0, maxHeight * 1.1)

    plt.xlabel("x (m)")
    plt.ylabel("y (m)")
    plt.title(f"v0 = {initialSpeed} m/s, target = ({targetX}, {targetY})")

    plt.show()


def main():
    # Speeds list
    speedValues = [100, 110, 120, 130, 140, 150]

    # Grid for the heatmap
    xValues = list(range(100, 1800, 100))   # 100 to 1700
    yValues = list(range(-50, 60, 10))      # -50 to 50

    # Kinda works, needs a better way to grab relevant x and y valyues
    for speed in speedValues:
        table = buildAngleTable(speed, xValues, yValues)
        plotAngleSweep(speed, xValues[5], yValues[5])



if __name__ == "__main__":
    main()
